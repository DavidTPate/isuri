var window =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["isUri"] = __webpack_require__(1);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var rfc3986 = __webpack_require__(2);

	// See: https://github.com/hapijs/hoek/blob/f62961d3d07aca68ab11480893e6e80a421914b4/lib/index.js#L783-L787
	function escapeRegex(string) {
	    // Escape ^$.*+-?=!:|\/()[]{},
	    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
	}

	var internals = {
	    Uri: {
	        createUriRegex: function (options) {
	            options = options || {};

	            if (typeof options !== 'object' || Array.isArray(options)) {
	                throw new Error('options must be an object');
	            }

	            var customScheme = '';

	            // If we were passed a scheme, use it instead of the generic one
	            if (options.scheme) {
	                if (!Array.isArray(options.scheme)) {
	                    options.scheme = [options.scheme];
	                }

	                if (options.scheme.length <= 0) {
	                    throw new Error('scheme must have at least 1 scheme specified');
	                }

	                for (var i = 0; i < options.scheme.length; ++i) {
	                    var currentScheme = options.scheme[i];

	                    if (!(currentScheme instanceof RegExp || typeof currentScheme === 'string')) {
	                        throw new Error('scheme must only contain Regular Expressions or Strings');
	                    }

	                    // Add OR separators if a value already exists
	                    customScheme = customScheme + (customScheme ? '|' : '');

	                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
	                    if (currentScheme instanceof RegExp) {
	                        customScheme = customScheme + currentScheme.source;
	                    } else {
	                        if (!/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(currentScheme)) {
	                            throw new Error('scheme at position ' + i + ' must be a valid scheme');
	                        }
	                        customScheme = customScheme + escapeRegex(currentScheme);
	                    }
	                }

	            }

	            // Have to put this in a non-capturing group to handle the OR statements
	            var scheme = '(?:' + (customScheme || rfc3986.scheme) + ')';

	            /**
	             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	             *
	             * OR
	             *
	             * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
	             */
	            return new RegExp('^(?:' + scheme + ':' + rfc3986.hierPart + ')(?:\\?' + rfc3986.query + ')?(?:#' + rfc3986.fragment + ')?$');
	        },
	        uriRegex: new RegExp(rfc3986.uri)
	    }
	};

	internals.Uri.isValid = function (val) {
	    return internals.Uri.uriRegex.test(val);
	};

	module.exports = {
	    createUriRegex: internals.Uri.createUriRegex,

	    uriRegex: internals.Uri.uriRegex,
	    isValid: internals.Uri.isValid
	};

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	// Load modules

	// Delcare internals

	var internals = {
	    rfc3986: {}
	};

	internals.generate = function () {

	    /**
	     * elements separated by forward slash ("/") are alternatives.
	     */
	    var or = '|';

	    /**
	     * DIGIT = %x30-39 ; 0-9
	     */
	    var digit = '0-9';
	    var digitOnly = '[' + digit + ']';

	    /**
	     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
	     */
	    var alpha = 'a-zA-Z';
	    var alphaOnly = '[' + alpha + ']';

	    /**
	     * cidr       = DIGIT                ; 0-9
	     *            / %x31-32 DIGIT         ; 10-29
	     *            / "3" %x30-32           ; 30-32
	     */
	    internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';

	    /**
	     * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
	     */
	    var hexDigit = digit + 'A-Fa-f';
	    var hexDigitOnly = '[' + hexDigit + ']';

	    /**
	     * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
	     */
	    var unreserved = alpha + digit + '-\\._~';

	    /**
	     * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
	     */
	    var subDelims = '!\\$&\'\\(\\)\\*\\+,;=';

	    /**
	     * pct-encoded = "%" HEXDIG HEXDIG
	     */
	    var pctEncoded = '%' + hexDigit;

	    /**
	     * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
	     */
	    var pchar = unreserved + pctEncoded + subDelims + ':@';
	    var pcharOnly = '[' + pchar + ']';

	    /**
	     * Rule to support zero-padded addresses.
	     */
	    var zeroPad = '0?';

	    /**
	     * dec-octet   = DIGIT                 ; 0-9
	     *            / %x31-39 DIGIT         ; 10-99
	     *            / "1" 2DIGIT            ; 100-199
	     *            / "2" %x30-34 DIGIT     ; 200-249
	     *            / "25" %x30-35          ; 250-255
	     */
	    var decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';

	    /**
	     * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
	     */
	    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;

	    /**
	     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
	     * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
	     * IPv6address =                            6( h16 ":" ) ls32
	     *             /                       "::" 5( h16 ":" ) ls32
	     *             / [               h16 ] "::" 4( h16 ":" ) ls32
	     *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
	     *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
	     *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
	     *             / [ *4( h16 ":" ) h16 ] "::"              ls32
	     *             / [ *5( h16 ":" ) h16 ] "::"              h16
	     *             / [ *6( h16 ":" ) h16 ] "::"
	     */
	    var h16 = hexDigitOnly + '{1,4}';
	    var ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
	    var IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
	    var IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
	    var IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
	    var IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
	    var IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
	    var IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
	    var IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
	    var IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
	    var IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';
	    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';

	    /**
	     * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
	     */
	    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';

	    /**
	     * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
	     */
	    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';

	    /**
	     * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
	     */
	    var userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';

	    /**
	     * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
	     */
	    internals.rfc3986.IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';

	    /**
	     * reg-name = *( unreserved / pct-encoded / sub-delims )
	     */
	    var regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';

	    /**
	     * host = IP-literal / IPv4address / reg-name
	     */
	    var host = '(?:' + internals.rfc3986.IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';

	    /**
	     * port = *DIGIT
	     */
	    var port = digitOnly + '*';

	    /**
	     * authority   = [ userinfo "@" ] host [ ":" port ]
	     */
	    var authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';

	    /**
	     * segment       = *pchar
	     * segment-nz    = 1*pchar
	     * path          = path-abempty    ; begins with "/" or is empty
	     *               / path-absolute   ; begins with "/" but not "//"
	     *               / path-noscheme   ; begins with a non-colon segment
	     *               / path-rootless   ; begins with a segment
	     *               / path-empty      ; zero characters
	     * path-abempty  = *( "/" segment )
	     * path-absolute = "/" [ segment-nz *( "/" segment ) ]
	     * path-rootless = segment-nz *( "/" segment )
	     */
	    var segment = pcharOnly + '*';
	    var segmentNz = pcharOnly + '+';
	    var pathAbEmpty = '(?:\\/' + segment + ')*';
	    var pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
	    var pathRootless = segmentNz + pathAbEmpty;

	    /**
	     * hier-part = "//" authority path
	     */
	    internals.rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';

	    /**
	     * query = *( pchar / "/" / "?" )
	     */
	    internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

	    /**
	     * fragment = *( pchar / "/" / "?" )
	     */
	    internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';

	    /**
	     * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	     *
	     * OR
	     *
	     * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
	     */
	    internals.rfc3986.uri = '^(?:' + internals.rfc3986.scheme + ':' + internals.rfc3986.hierPart + ')(?:\\?' + internals.rfc3986.query + ')?' + '(?:#' + internals.rfc3986.fragment + ')?$';
	};

	internals.generate();

	module.exports = internals.rfc3986;

/***/ }
/******/ ]);